\chapter{Network Values}
There are several network properties that, instead of being stored in a variable, have getters to them. These either have to be calculated on the fly or don't really serve an internal purpose that would justify storing them inside a variable property.

Getters have the basic format:

\begin{minted}[bgcolor=bg]{ts}
get getter_name(): PropertyType {
  return property;
}
\end{minted}

And, different from functions, can be accessed without the brackets:

\begin{minted}[bgcolor=bg]{ts}
net.getter_name
\end{minted}

\section{Functional Getters}
These getters exist mostly to provide functionality to the network class.
For example,
the \mintinline{ts}{args} getter returns some of the properties of the network necessary to make a copy of it:

\begin{minted}[bgcolor=bg]{typescript}
  get args(): NetworkArgs {
    return {
      is_directed: this.is_directed,
      is_multigraph: this.is_multigraph,
      edge_limit: this.edge_limit,
      vertex_limit: this.vertex_limit,
    };
  }
\end{minted}

The list getters return a list with the values inside the vertices and edges \mintinline{ts}{Maps}.
This is particularly useful for efficiency as it makes it possible to use standard \mintinline{ts}{Array} functions.

\begin{minted}[bgcolor=bg]{ts}
  get vertex_list(): Vertex[] {
    return [...this.vertices.values()];
  }

  get edge_list(): Edge[] {
    return [...this.edges.values()];
  }
\end{minted}

The \mintinline{ts}{...} destructuring operator was also introduced in ES2021.
It takes the iterable return of the \mintinline{ts}{values()}
function and destructures it into its individual elements.
The elements are then put inside an array, which is finally returned by the getter.

\section{Calculations}
These next getters involve calculations that make use of the network's vertices and edges.
That is why they are not permanently stored inside a property,
seeing as they could change any time a new edge or vertex is added to the graph.

The calculations are also not turned into their own functions because they do not
require algorithms that are too elaborate.

\subsection{Weight}

\begin{minted}[bgcolor=bg]{ts}
  get weight(): number {
    return this.vertex_list
      .map((vertex) => vertex.weight)
      .reduce((prev, curr) => prev + curr);
  }
\end{minted}

Say $w(x)$ is the weight of the vertex $x$ in the network $G=(V,E)$. A network's weight is given by:
$$\sum{w(x)}, \forall x \in G$$

The getter uses the 'Array.prototype.map' and 'Array.prototype.reduce' functions.
It first maps the 'vertex\_list' into a list with just the weights of the vertex, and then reduces it by summing all of the new list's values.

There are three other functions related to vertex weight.

\begin{minted}[bgcolor=bg]{ts}
/**
 * List of vertices with negative weight.
 * @returns Vertex[]
 */
  get negative_vertices(): Vertex[] {
  const { vertex_list } = this;
  return vertex_list.filter((vertex) => vertex.weight < 0);
}

/**
 * List of vertices with positive weight.
 * @returns Vertex[]
 */
get positive_vertices(): Vertex[] {
  const { vertex_list } = this;
  return vertex_list.filter((vertex) => vertex.weight > 0);
}

/**
 * List of vertices with zero weight.
 * @returns Vertex[]
 */
get zero_vertices(): Vertex[] {
  const { vertex_list } = this;
  return vertex_list.filter((vertex) => vertex.weight == 0);
}
\end{minted}

\subsection{Maximum Number of Edges}
The largest number of edges $M_E$ a graph with $|V|$ vertices can have is:
$$M_E=\frac{|V|*(|V|-1)}{2}$$
Where $|V|$ represents the size of the vertex set $V$.

\begin{minted}[bgcolor=bg]{ts}
  get max_edges(): number {
    return (this.vertices.size * (this.vertices.size - 1)) / 2;
  }
\end{minted}

\subsection{Density}

A graph's density $D$ is defined by:
$$D=\frac{|E|}{M_E}$$
Where $|E|$ is the size of the edge set $|E|$
The number of edges a graph has,
divided by the maximum number of edges it could have with the number of nodes it currently has.

\begin{minted}[bgcolor=bg]{typescript}
  get density(): number {
    return this.edges.size / this.max_edges;
  }
\end{minted}