\chapter{Algorithms}

Algorithms are the most important part of NeTS,
and any other network science library.
They are useful for demonstrating and understanding
fundamental aspects of networks.
As we will see, they can express how connected
a social network is, or even show a profitable exchange path
in a given market.

\section{Neighborhood}
A vertex $x$'s neighborhood $H(x)$ is defined as the vertices that are connected to that vertex
by an edge. Note also that $H_x\subset V$.
$H[x]$ is used to define the set with neighbors of $x$ as well as $x$ itself: $H[x]=H(x)+x$.

In a social network, the neighborhood of a vertex represents
the immediate connections of a user.

In a network that represents the global exchange market for
commodities, the neighborhood can be used to represent
the trade partners of a given country.

The \mintinline{ts}{Network.neighbors(id)}
function returns a list with the IDs of the neighbors of the vertex given.

\begin{minted}[bgcolor=bg]{ts}
neighbors(id: base_id): base_id[] {
  const neighborhood: base_id[] = [];

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id) neighborhood.push(to);
    else if (to === id) neighborhood.push(from);
  });

  return neighborhood;
}
\end{minted}

It goes through the Map of edges,
and finds any edge that has one of its vertices match the parameter ID.

When a network is directed, an edge can have two distinct types of neighbors.
In-neighbors are vertices that connect to a vertex $a$ with an edge that ends on $a$.
In other words, for a vertex $a$ in an edge from $b$ to $a$, $b$ is an in-neighbor of $a$.
Out-neighbors are the opposite.

\begin{minted}[bgcolor=bg]{ts}
inNeighbors(id: base_id): base_id[] {
  const in_neighbors: base_id[] = [];
  if (!this.is_directed) return in_neighbors;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (to === id) in_neighbors.push(from);
  });

  return in_neighbors;
}

outNeighbors(id: base_id): base_id[] {
  const out_neighbors: base_id[] = [];
  if (!this.is_directed) return out_neighbors;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id) out_neighbors.push(to);
  });

  return out_neighbors;
}
\end{minted}

\section{Degree}

The degree of a vertex can be defined as the number of edges that contain said vertex.

$$E_x=\{k \mid k \in E, x \in k\}$$
$$D_x=|E_x|$$

The degree of a vertex is, in other words, the number of neighbors for said vertex.
In the example of a social network, the degree of a user would
tells us how many connections that user has in the network.

In the library:

\begin{minted}[bgcolor=bg]{ts}
degree(id: base_id): number {
  let vertex_degree = 0;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id || to === id) vertex_degree++;
  });

  return vertex_degree;
}
\end{minted}

The two other degree functions are related to in and out-neighbors,
and are only defined when a network is directed.
\mintinline{ts}{inDegree} returns the number of edges that end on the given edge.
\mintinline{ts}{outDegree} does the opposite,
returning the number of edges that start on the given vertex.

For a directed network that represents global debt,
let edges be directed from borrower to lender, and vertices
represent countries or international organizations.
We could predict that the IMF, for example, has a high out-degree,
as it is a money lender for many countries.
Countries with high in-degree would be those with many debts to pay.

\begin{minted}[bgcolor=bg]{ts}
inDegree(id: base_id): number {
  let in_degree = 0;
  if (!this.is_directed) return in_degree;

  this.edges.forEach(({ vertices }) => {
    const { to } = vertices;
    if (to === id) in_degree++;
  });

  return in_degree;
}

outDegree(id: base_id): number {
  let out_degree = 0;
  if (!this.is_directed) return out_degree;

  this.edges.forEach(({ vertices }) => {
    const { from } = vertices;
    if (from === id) out_degree++;
  });

  return out_degree;
}
\end{minted}

The average degree of a vertex is defined as the sum all its neighbor's degrees over its own degree.
For a vertex $i$, it is usually written as:

$$k_{nn}(i)=\frac{\sum{a_{ij}D(j)}}{j_i}$$

Where $a_{ij}$ is positive if there is and edge between vertices $i$ and $j$,
and $D(j)$ is the degree of vertex $j$.
And this is what this would look like when literally transcribed into code:

\begin{minted}[bgcolor=bg]{ts}
averageDegree(id: base_id): number {
  let neighbor_degree_sum = 0;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id) neighbor_degree_sum += this.degree(to);
    else if (to === id) neighbor_degree_sum += this.degree(from);
  });

  return neighbor_degree_sum / this.degree(id);
}
\end{minted}

However, as previously mentioned, we already have a function for getting the neighbors of
a specific vertex.
Thus, we could write the averageDegree $A_x$ of vertex $x$ as:

$$A_x=\frac{\sum{D(i)}}{D(x)}, i\in H(x)$$

In code:

\begin{minted}[bgcolor=bg]{ts}
averageDegree(id: base_id): number {
  let neighbor_degree_sum = 0;

  this.neighbors(id).forEach((neighbor_id) => {
    neighbor_degree_sum += this.degree(neighbor_id);
  });

  return neighbor_degree_sum / this.degree(id);
}
\end{minted}

This helps us avoid repetition and makes things more clear.
If someone who doesn't know what an average degree is were to look at this,
they would have an easier time figuring out what it means.

\section{Assortativity}

Assortativity is a fairly complex algorithm.


In this library, auxiliary functions were created to help calculate it:

\begin{minted}[bgcolor=bg]{ts}
edgeAverageOperationList(
    operations: ((vertices: EdgeArgs) => number)[]
  ) {
  let totals = new Array(operations.length).fill(0);
  this.edges.forEach(
    ({ vertices }) =>
      (totals = totals.map(
        (total, index) => (total += operations[index](vertices))
      ))
  );

  return totals.map((total) => total / this.edges.size);
}
\end{minted}

This function borrows an important idea from functional programming.
The parameter it takes in is an array of functions.
The functions have the format:

\begin{minted}[bgcolor=bg]{ts}
(vertices: EdgeArgs) => number
\end{minted}

They take in \mintinline{ts}{EdgeArgs} and output a number.
For example, an input function could be:

\begin{minted}[bgcolor=bg]{ts}
const in_function =
  ({ from, to }) =>
    this.vertices.get(from).weight +
    this.vertices.get(to).weight;
\end{minted}

In essence, this function takes in two vertex IDs that belong to an edge and sums their weights.
Although the function tecnically expects \mintinline{ts}{EdgeArgs},
the two properties of this type that we are really interested in are \mintinline{ts}{from}
and \mintinline{ts}{to} (the two vertices in an edge).

Assortativity makes use of \mintinline{ts}{edgeAverageOperationList()}.

\begin{minted}[bgcolor=bg]{ts}
assortativity(): number {
  const [edge_multi, edge_sum, edge_sqr_sum] =
    this.edgeAverageOperationList([
      ({ from, to }) => this.degree(from) * this.degree(to),
      ({ from, to }) => this.degree(from) + this.degree(to),
      ({ from, to }) => this.degree(from) ** 2 +
                        this.degree(to) ** 2,
    ]);

  return (
    (4 * edge_multi - edge_sum ** 2) /
    (2 * edge_sqr_sum - edge_sum ** 2)
  );
}
\end{minted}

We adopted the formula:

$$r=\frac{(4\langle k_a k_b\rangle-\langle k_a+k_b\rangle^2)}{2\langle k_a^2+k_b^2\rangle-\langle k_a+k_b\rangle}$$

The expressions inside $\langle$$\rangle$ represent
an operation performed over all edges
that is then averaged,
where $k_a$ and $k_b$ are the endpoints of each edge.

There is another function in the Network class called \mintinline{ts}{edgeAverageOperation()}.
It works almost exactly like its 'List' version, except it only takes in one operation.
The list version makes assortativity $O(c)$, where $c$ is a constant.
That is because the operations are done one after the other in a single loop through all edges.
If \mintinline{ts}{edgeAverageOperation()} was used instead, it would make an algorithm like assortativity $O(n)$ (linear complexity).
$n$ being the number of operations necessary, since each operation would need an entire loop through the network's edges.

\section{Complement}

The complement of a network $N$ is a network $N_c$ with the same number of vertices,
but with all the edges $N$ doesn't have.
That is to say, let $E(N)$ be the set of edges in $N$,
and $E(N_c)$ the set of edges in $N_c$, the edge $e$:

$$e\in E(N_c)\iff e \notin E(N)$$

The complement function has no inputs, and returns a Network object.
\begin{minted}[bgcolor=bg]{ts}
complement(): Network {
  const complement_network =
    new Network({ is_directed: this.is_directed });

  this.vertices.forEach((vertex_a) => {
    const { id: id_a } = vertex_a;
    this.vertices.forEach((vertex_b) => {
      const { id: id_b } = vertex_b;
      if (id_a !== id_b) {
        if (!this.hasEdge(id_a, id_b))
          complement_network.addEdge({
            from: id_a, to: id_b
          });
        if (complement_network.is_directed &&
            !this.hasEdge(id_b, id_a))
          complement_network.addEdge({
            from: id_b, to: id_a
          });
      }
    });
  });

  return complement_network;
}
\end{minted}

It goes through every vertex and if it finds two vertices that don't have an edge in the network,
it adds it to the complement.

\section{Ego}

The ego is the subgraph induced in the set $H[x]$.

The ego $G_x$ of a vertex $x$ from a network $N=(V,E)$ is the set $V(G_x)$ (vertices of the $G_x$)
of all vertices that have an edge with it, as well as all the edges with vertices in $V(G_x)$.

Formally:
$$V(G_x) \subset V, E(G_x) \subset E$$

$$E(G_x)=\{e : v_e,u_e \in H_x\}$$

In the library, the algorithm takes in a vertex's ID, and returns a Network instance.
\begin{minted}[bgcolor=bg]{ts}
ego(id: base_id): Network {
  const ego_network = new Network(this.args);

  this.edges.forEach((edge) => {
    const { from, to } = edge.vertices;
    if (from === id || to === id) {
      ego_network.addEdge({ from, to });
    }
  });

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (ego_network.vertices.has(from) &&
        ego_network.vertices.has(to))
      ego_network.addEdge({ from, to });
  });

  return ego_network;
}
\end{minted}

\begin{figure}[H]
  \centering
  \includegraphics[scale=.25]{img/ego_3.png}
  \caption{3's ego includes $0,1,3,4,7,8,9$ and all edges between them.}
  \label{fig:core_ex}
\end{figure}

First, the algorithm goes through all edges, and add to the \mintinline{ts}{ego_network}
the ones that contain the given vertex.
Then, it goes through the edges of the network again,
this time adding edges that don't connect to the ego vertex,
but connect to vertices already in the ego network.

\section{Copy}

It is very useful to have a copy of a network
when we want another network that derives from it.
For example, a core-decomposition (as we will see next)
makes use of the copy function.

Because of the way JS works, making a copy of a class' instance
is not as simple as:
\begin{minted}[bgcolor=bg]{ts}
const net_copy = net;
\end{minted}

This method works more like a reference to the original object.
If a property of net changes, \mintinline{ts}{net_copy} will also change.

Nevertheless, there are many other ways of making copies of objects with JS.
Here are som of the most common:
\begin{minted}[bgcolor=bg]{ts}
// Destructuring:
const copy_destructure = { ...net }

// Assign:
const copy_assign = Object.assign({}, net)

// JSON:
const copy_json = JSON.parse(JSON.stringify(net))
\end{minted}

However, none of these suit our need for a completely independent copy.
For destructuring, although simple properties such as the maximum number of edges of the Network would be properly copied,
objects (which are most of the network) would still become references.
Assigning has the same issue.
The edges property, for instance, would become a reference because it is a Map.
So if an edge is added to the original, the copy would also receive it.

The JSON method solves this problem.
It transforms the network into a JSON string, and then transforms it back into an object with JSON.parse().
The big problem with this is that the copy is no longer a network instance, just an object with many of the properties a network would have.
This is an issue we would want to avoid even more when we consider typing and interfaces are precisely why TS was chosen.

Thus, the copy algorithm works differently, and is specific to the Network class:

\begin{minted}[bgcolor=bg]{ts}
copy(): Network {
  const network_copy = new Network(this.args);
  network_copy.addEdgeMap(this.edges);
  network_copy.addVertexMap(this.vertices);
  return network_copy;
}
\end{minted}

\section{Core}

A k-core decomposition of a network $N$ is a subgraph $C_k$ with any
$v\in V(N)$ with $D_v<k$ removed.
$$C_k={v,e:v\in V(N), D_v\geq k,e\in E(N)}$$
It is a function that only ends after all vertices with degree less than $k$ are removed.

\begin{minted}[bgcolor=bg]{ts}
core(k: number): Network {
  const k_decomposition = this.copy();

  while (k > 0 && k_decomposition.vertices.size > 0) {
    let { vertex_list } = k_decomposition;
    let vertex_counter;
    for (
      vertex_counter = 0;
      vertex_counter < vertex_list.length;
      vertex_counter++
    ) {
      const current_vertex =
        k_decomposition.vertex_list[vertex_counter];
      if (k_decomposition.degree(current_vertex.id) < k) {
        k_decomposition.removeVertex(current_vertex.id);
        vertex_list = k_decomposition.vertex_list;
        vertex_counter = 0;
      }
    }
    k--;
  }

  return k_decomposition;
}
\end{minted}

\begin{figure}[H]
  \centering
  \includegraphics[scale=.25]{img/core_ex.png}
  \caption{A 2-core decomposition would remove nodes $1,9,7,8$. $8$ would be removed in the second iteration of the function.}
  \label{fig:core_ex}
\end{figure}


\section{Clustering}

The clustering coefficient measures how connected the neighbors of a vertex are to each other.
It is the number of edges that exists in between the vertex's neighbors in relation to the
maximum number of edges that could exist there.

$$\frac{|{e:v,u\in e \and v,u\in H[x]}|}{|H[x]|(|H[x]|-1)}$$

\begin{minted}[bgcolor=bg]{ts}
clustering(id: base_id): number {
  const ego_net = this.ego(id);

  if (ego_net.vertices.size <= 1) return 0;

  const centerless_ego = ego_net;

  // Max edges in a network without the given vertex.
  centerless_ego.removeVertex(id);
  const { max_edges } = centerless_ego;
  const existing_edges = centerless_ego.edges.size;

  // If graph is directed, multiply result by 2.
  const directed_const = this.is_directed ? 2 : 1;

  return directed_const * (existing_edges / max_edges);
}
\end{minted}

The algorithm makes use of the \mintinline{ts}{ego()} function, removing the ID vertex after.
It also uses a tenary operator because the only difference between the clustering
from a directed network to an undirected one is
that the former has its clustering multiplied by 2.

\section{Average Clustering}

This function calculates the average clustering of the network.
If calculates the clustering of all vertices, inserting its values into an array.
It then reduces the array, summing all of its values.
Finally, it returns the average, which devides the sum by the number of vertices in the network.
\begin{minted}[bgcolor=bg]{ts}
averageClustering(): number {
  let average_clustering = 0;

  if (this.vertices.size <= 1) return average_clustering;

  const clustering_sum = this.vertex_list
    .map((vertex) => this.clustering(vertex.id))
    .reduce((prev, curr) => prev + curr);

  average_clustering = clustering_sum / this.vertices.size;

  return average_clustering;
}
\end{minted}

\section{Triplets}

Triplets, also called triangles or triples, are the foundation
of design theory, an entrire field of mathematics.
Design theory is concerned with decomposing graphs into triplets.

A triplet is a set of 3 vertices and 3 edges connecting said vertices.
They are also called triples, triangles and $K_3$s, and are the foundation of design theory,
an entire field of mathematics.
\begin{figure}[H]
  \centering
  \includegraphics[scale=.25]{img/triplets.png}
  \caption{This network has two triplets: $\{5,7,8\}$ and $\{2,8,9\}$.}
  \label{fig:core_ex}
\end{figure}
This algorithm in the network went through many iterations that improved its performance.
The first algorithm looked through all edges, and, while in each edge,
looked through all nodes and checked for any that had edges with the two nodes in the edge.
The most glaring problem with this is that it ends up each triplet three times:
once for each edge.

The solution was to order the triplets so that, internally, the algorithm
sees $5,8,7$ as different from $5,7,8$, for example.
This was initially done by comparing the triplet that could be created
with the sorted version of that triplet.
The current improved version only needs to check if the current vertices are already sorted:
\begin{minted}[bgcolor=bg]{ts}
k2.isSameTriplet(triplet, triplet.sort())
\end{minted}

The current iteration of this algorithm also does not go through all vertices in the network.
It only looks through the neighbors of one of the vertices in the edge being analysed.
This also saves us from having to check if both vertices have edges to the vertice beeing looked at.

\begin{minted}[bgcolor=bg]{ts}
triplets(): Triplet[] {
  const triplet_list: Triplet[] = [];

  const k2 = this.core(2);

  const { vertices, edges } = k2;

  edges.forEach((edge) => {
    const { from, to } = edge.vertices;
    k2.neighbors(from).forEach((id) => {
      if (edge.hasVertex(id)) return;
      const triplet: Triplet = [id, ...[from, to].sort()];
      if (k2.isSameTriplet(triplet, triplet.sort()))
        if (k2.hasEdge(id, to, true))
          triplet_list.push(triplet);
    });
  });

  return triplet_list;
}
\end{minted}

Overall, there was a 27\% reduction in the algorithm's by only using sorted triplets;
then we saw around 55\% impovement
from only looking through the neighbors of an edge's vertex;
finally, there was a 10\% improvement in performance
by not having to edge-check one of the vertices.
All of these were cummulative.
