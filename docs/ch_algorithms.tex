\chapter{Algorithms}

\section{Neighborhood}
A vertex's neighborhood is defined as the vertices that are connected to that vertex by an edge.
The 'Network.neighbors(id)' function returns a list with the IDs of the given vertex's neighbors. 

\begin{minted}[bgcolor=bg]{ts}
 neighbors(id: base_id): base_id[] {
  const neighborhood: base_id[] = [];

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id) neighborhood.push(to);
    else if (to === id) neighborhood.push(from);
  });

  return neighborhood;
}
\end{minted}

It goes through the Map of edges, and finds any edge that has one of its vertices match the ID given.

When a network is directed, an edge can have two distinct types of neighbors.
In-neighbors are vertices that connect to a vertex $a$ with an edge that ends on $a$.
In other words, for a vertex $a$ in an edge from $b$ to $a$, $b$ is an in-neighbor of $a$.
Out-neighbors are the opposite.

\begin{minted}[bgcolor=bg]{ts}
inNeighbors(id: base_id): base_id[] {
  const in_neighbors: base_id[] = [];
  if (!this.is_directed) return in_neighbors;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (to === id) in_neighbors.push(from);
  });

  return in_neighbors;
}

outNeighbors(id: base_id): base_id[] {
  const out_neighbors: base_id[] = [];
  if (!this.is_directed) return out_neighbors;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id) out_neighbors.push(to);
  });

  return out_neighbors;
}
\end{minted}

\section{Degree}

A vertex's degree can be defined as the number of edges that contain said vertex.

$$E_x=\{k \mid k \in E, x \in k\}$$
$$D_x=|E_x|$$

In the library:

\begin{minted}[bgcolor=bg]{ts}
/**
 * Return the degree of a vertex with the given ID.
 * @param  {base_id} id
 * @returns number
 */
degree(id: base_id): number {
  let vertex_degree = 0;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id || to === id) vertex_degree++;
  });

  return vertex_degree;
}
\end{minted}

The two other degree functions are related to in and out-neighbors,
and are only defined when a network is directed.
'inDegree' returns the number of edges that end on the given edge.
'outDegree' does the opposite, returning the number of edges that start on the given vertex.

\begin{minted}[bgcolor=bg]{ts}
inDegree(id: base_id): number {
  let in_degree = 0;
  if (!this.is_directed) return in_degree;

  this.edges.forEach(({ vertices }) => {
    const { to } = vertices;
    if (to === id) in_degree++;
  });

  return in_degree;
}

outDegree(id: base_id): number {
  let out_degree = 0;
  if (!this.is_directed) return out_degree;

  this.edges.forEach(({ vertices }) => {
    const { from } = vertices;
    if (from === id) out_degree++;
  });

  return out_degree;
}
\end{minted}

\section{Assortativity}

Assortativity relates to a vertex's propensity to connect to other vertices that have similar properties.
In this algorithm, the property used as reference is a vertex's degree.

Assortativiry of a vertex $i$ is usually written as:

$$k_{nn}(i)=\frac{\sum{a_{ij}k_{j}}}{j_i}$$

Where $a_{ij}$ is positive if there is and edge between vertices $i$ and $j$,
and $k_j$ is the degree of vertex $j$.
And this is what this would look like when literally transcribed into code:

\begin{minted}[bgcolor=bg]{ts}
assortativity(id: base_id): number {
  let vertex_assortativity = 0;

  this.edges.forEach(({ vertices }) => {
    const { from, to } = vertices;
    if (from === id) vertex_assortativity += this.degree(to);
    else if (to === id) vertex_assortativity += this.degree(from);
  });

  return vertex_assortativity / this.degree(id);
}
\end{minted}

However, as previously mentioned, we already have a function for getting the neighbors of a specific vertex.
Thus, we could write our assortativity $A_x$ of vertex $x$ as:

$$A_x=\frac{\sum{D_n(x)}}{D_x}$$

In code:

\begin{minted}[bgcolor=bg]{ts}
assortativity(id: base_id): number {
  let vertex_assortativity = 0;

  this.neighbors(id).forEach((neighbor_id) => {
    vertex_assortativity += this.degree(neighbor_id)
  });

  return vertex_assortativity / this.degree(id);
}
\end{minted}

This helps us avoid repetition and makes things more clear.
If someone who doesn't know what assortativity is were to look at this
they would have an easier time figuring out what it means.

Saved 10 seconds from triplets by only using directed edges