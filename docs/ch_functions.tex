\chapter{Functions}

The functions for removing edges and vertices are self-explanatory in their name.

\begin{minted}[bgcolor=bg]{ts}
  removeEdge(args:
            { from: base_id; to: base_id; id?: base_id }) {
    if (args.id !== undefined) {
      this.removeMultigraphEdge(args.id);
      return;
    } else if (this.is_multigraph) {
      throw { message: ERROR.UNDEFINED_ID, id: args.id };
    }

    this.edges.forEach(({ vertices }, id) => {
      if (this.checkEdgeIsSame(vertices, args)) {
        this.edges.delete(id);
        return;
      }
    });
  }
\end{minted}

The 'removeVertice' function differs itself from 'removeEdge'.
When a vertex is removed, all of the edges associated with it also have to be removed.

\begin{minted}[bgcolor=bg]{ts}
  removeVertex(id: base_id) {
    if (!this.vertices.has(id))
      throw { message: ERROR.INEXISTENT_VERTICE, vertex: id };

    this.vertices.delete(id);

    this.edges.forEach(({ vertices }, key) => {
      const { from, to } = vertices;
      if (from === id || to === id)
        this.edges.delete(key)
    });
  }
\end{minted}

An advantage of using Maps to store the network's vertices and edges is that it is easier to get them by ID:

\begin{minted}[bgcolor=bg]{ts}
  hasVertex(id: base_id): boolean {
    return this.vertices.has(id);
  }
\end{minted}

To get an edge between two vertices, 'Array.prototype.find' is used in the 'edge\_list' array.
The 'find()' function returns the first element in the list that fulfills the given property.

\begin{minted}[bgcolor=bg]{ts}
  /**
   * Returns the edge between two nodes.
   * @param  {base_id} from
   * @param  {base_id} to
   * @returns base_id[]
   */
   edgeBetween(
    from: base_id,
    to: base_id,
    is_directed = this.is_directed
  ): Edge | undefined {
    return this.edge_list.find(({ vertices }) =>
      this.checkEdgeIsSame(vertices, { from, to }, is_directed)
    );
  }
\end{minted}

The property fed into the function checks if the vertices given to 'edgeBetween()' form an edge
that is the same as an edge that actually exists in the network. To check if two edges are the same
(if they have the same 'from' and 'to') the private function 'checkEdgeIsSame()' is used.

A private function can only be accessed inside the class declaration.

\begin{minted}[bgcolor=bg]{ts}
checkEdgeIsSame(
    edge_a: EdgeArgs,
    edge_b: EdgeArgs,
    is_directed = this.is_directed
  ): boolean {
    if (edge_a.from === edge_b.from && edge_a.to === edge_b.to)
      return true;
    else if (
      edge_a.to === edge_b.from &&
      edge_a.from === edge_b.to &&
      !is_directed
    )
      return true;
    return false;
  }
\end{minted}

The way an edge check works depends on whether a network is directed or not.

Nevertheless, it is also possible to force an undirected check.
This is useful when it is only necessary to know if an edge between $A$ and $B$ exists at all, 
instead of whether a \textit{directed} edge from $A$ to $B$ exists.

There are also two functions that serve mostly as a convenience.

\begin{minted}[bgcolor=bg]{ts}
  newVID(): base_id {
   let id = this.free_vid++;
   while (this.vertices.has(id)) {
     id = Math.floor(Math.random() * this.vertex_limit);
   }
   return id;
 }
 
 newEID() {
   let id = this.free_eid++;
   while (this.edges.has(id)) {
     id = Math.floor(Math.random() * this.edge_limit);
   }
   return id;
 }
\end{minted}

These ID functions help create new IDs to be assigned to new edges or vertices.
On the user level, there rarelly is any reason to assign IDs to edges.
However, since the network uses Maps, when an edge is created, it needs to have
an ID assigned to it.
The 'newEID()' function generates a valid ID to be used internally.

Other utility functions are:

\begin{minted}[bgcolor=bg]{ts}
addEdge(args: EdgeArgs) {
  args.do_force ??= true;
  args.weight ??= 1;

  args.id ??= this.newEID();

  if (this.edges.has(args.id))
    throw { message: ERROR.EXISTING_EDGE };

  if (this.edges.size >= this.edge_limit)
    throw { message: ERROR.EDGE_LIMIT };

  if (!args.do_force) {
    if (!this.vertices.has(args.from))
      throw {
        message: ERROR.INEXISTENT_VERTICE,
        vertex: args.from
      };
    if (!this.vertices.has(args.to))
      throw {
        message: ERROR.INEXISTENT_VERTICE,
        vertex: args.to
      };
  } else {
    if (!this.vertices.has(args.from))
      this.addVertex({ id: args.from });
    if (!this.vertices.has(args.to))
      this.addVertex({ id: args.to });
  }

  if (!this.is_multigraph && this.hasEdge(args.from, args.to))
    return;

  this.edges.set(args.id, new Edge(args));
}

/**
 * Add multiple edges from a map of edges.
 * @param  {Map<base_id, Edge>} edge_map
 */
addEdgeMap(edge_map: Map<base_id, Edge>) {
  edge_map.forEach((edge, id) => this.edges.set(id, edge));
}

/**
 * Add multiple edges from a list of EdgeArgs.
 * @param  {EdgeArgs[]} edge_list
 */
addEdgeList(edge_list: EdgeArgs[]) {
  edge_list.forEach((edge_args, id) =>
    this.edges.set(id, new Edge(edge_args))
  );
}

/**
 * Returns true if an edge (undirected)
 * between from and to exists.
 * @param  {base_id} from
 * @param  {base_id} to
 * @returns boolean
 */
hasEdge(from: base_id,
        to: base_id,
        is_directed = false): boolean {
  return this.edge_list.some(({ vertices }) =>
    this.checkEdgeIsSame(vertices, { from, to }, is_directed)
  );
}

/**
 * Returns a list of edges between two given nodes.
 *
 * @param  {base_id} from
 * @param  {base_id} to
 * @returns base_id[]
 */
getEdgesBetween(
  from: base_id,
  to: base_id,
  is_directed = this.is_directed
): base_id[] | base_id {
  let edge_list: base_id[] = [];

  this.edges.forEach(({ vertices }, id) => {
    if (this.checkEdgeIsSame(
                              vertices,
                              { from, to },
                              is_directed
                            )) {
      edge_list.push(id);
    }
  });

  return this.is_multigraph ? edge_list : edge_list[0];
}

addVertex(args: VertexArgs) {
  if (this.vertices.size >= this.vertex_limit)
    throw { message: ERROR.VERTICE_LIMIT };
  if (args.id !== undefined && this.vertices.has(args.id))
    throw { message: ERROR.EXISTING_VERTICE };

  this.vertices.set(args.id, new Vertex(args));
}

/**
 * Add multiple vertices from a map of vertices.
 * @param  {Map<base_id, Vertex>} vertex_map
 */
addVertexMap(vertex_map: Map<base_id, Vertex>) {
  vertex_map.forEach((vertex, id) =>
    this.vertices.set(id, vertex));
}

/**
 * Add multiple vertices from a list of VertexArgs.
 * @param  {VertexArgs[]} vertex_list
 */
addVertexList(vertex_list: VertexArgs[]) {
  vertex_list.forEach((vertex_args, id) =>
    this.vertices.set(id, new Vertex(vertex_args))
  );
}
\end{minted}

There are also some private utility functions that are used in algorithms
that will be explained in the next chapter.

\begin{minted}[bgcolor=bg]{ts}
  listHasTriplet(triplet_arr: Triplet[],
                 triplet: Triplet): boolean {
    return !!triplet_arr.find((trip) =>
      this.isSameTriplet(triplet, trip));
  }

  isSameTriplet(arr1: Triplet, arr2: Triplet): boolean {
    if (arr1.length !== arr2.length) return false;
    return arr1.every((element, index) =>
      element === arr2[index]);
  }
\end{minted}